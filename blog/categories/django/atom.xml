<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: django | pfigue]]></title>
  <link href="http://pfigue.github.io/blog/categories/django/atom.xml" rel="self"/>
  <link href="http://pfigue.github.io/"/>
  <updated>2013-11-28T13:11:35+01:00</updated>
  <id>http://pfigue.github.io/</id>
  <author>
    <name><![CDATA[pfigue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Running Django administrative commands as cronjobs]]></title>
    <link href="http://pfigue.github.io/blog/2013/08/14/running-django-administrative-commands-as-cronjobs/"/>
    <updated>2013-08-14T18:17:00+02:00</updated>
    <id>http://pfigue.github.io/blog/2013/08/14/running-django-administrative-commands-as-cronjobs</id>
    <content type="html"><![CDATA[<p>My best practices (at the moment) to install periodic django administrative commands.</p>

<h1>Crontabs</h1>

<p>First of all, there are three crontabs:</p>

<ul>
<li> the system one (<em>/etc/crontab</em>)</li>
<li> and the user&rsquo;s one (<em>/var/spool/cron/crontabs/root</em>, e.g.).</li>
<li> those in <em>/etc/cron.d/</em>. Newly installed packages may want to install their cronjobs there.</li>
</ul>


<p>The syntax is different:</p>

<ul>
<li> in the system crontab (and /etc/cron.d) you indicate which user runs the cronjob.</li>
<li> while in the user&rsquo;s cronjob it is the user itself who runs the cronjobs.</li>
</ul>


<p>And the way to manipulate the files as well:</p>

<ul>
<li> system crontab is manipulated editing directly <em>/etc/crontab</em> or <em>/etc/cron.d/file</em>. Usually it is a script (like a <em>postinstall script</em> in a package) who updates it.</li>
<li><p> user&rsquo;s crontab is manipulated via the <code>crontab</code> command:</p>

<ul>
<li><code>crontab -e</code> to edit. <code>export EDITOR=/usr/bin/vim</code> may help, unles you like <em>nano</em>.</li>
<li>and <code>crontab -l</code> to list (piping to <em>less</em>, for example).</li>
</ul>
</li>
</ul>


<p>Note that the command <strong>checks the syntax of the crontab</strong>.</p>

<p>Where to put the cronjobs is up to you. In my case we were using the system crontab but we switched to root&rsquo;s crontab, as we were introducing the cronjobs manually and would like to have a syntax check, just in case.</p>

<h1>Wrapping for manage.py</h1>

<p>To make <strong>manage.py</strong> run you need to provide some <strong>environment variables</strong>. Some of them to activate the virtual environment of your python webapp, others maybe to provide configuration parameters for your webapp (database server, port, credentials, etc.). Also, the python interpreter you should use is the one in your virtualenv. Maybe a wrapper like this in <code>/root/tools/django_cronjobs_wrapper.sh</code> becomes handy:</p>

<pre><code>#!/bin/bash
# Wrapper to run cronjobs

if [ $# -eq 0 ]; then
    echo "usage: $0 {command for manage.py}"
    exit 1
fi

export SETTINGS_FILE='/etc/acme/webapp_settings.conf'
export PYTHONPATH='/opt/acme/webapp_env/'
export PYTHONHOME='/opt/acme/webapp_env'
$PYTHONHOME/bin/python /opt/acme/webapp/code/manage.py $*
</code></pre>

<p>The return value is the one of the manage.py command (useful for cron to know if it failed). <em>Stderr</em> and <em>stdout</em> are not redirected anywhere at the moment.</p>

<p>Indeed, you can extend this wrapper to run <strong>manage.py commands</strong> in the shell, for example a <strong>shell_plus session</strong>, or run a <strong>celery consumer</strong> from <em>Upstart</em> or <em>Supervisor</em>.</p>

<p>Note: I had to change the group of the file to <em>crontab</em> and give it exec. permission:</p>

<pre><code>-rwxr-xr-- 1 root crontab 1055 Aug 7 18:00 tools/django_cronjobs_wrapper.sh
</code></pre>

<h1>Installing the cronjob</h1>

<p>For example:</p>

<pre><code>5 * * * * /root/tools/django_cronjobs_wrapper.sh a_csv_export --for --example &gt;&gt; /var/log/acme/cronjobs/a_csv_export.log
</code></pre>

<p>This would be for a user&rsquo;s crontab. Note that <strong>stdout</strong> goes to a logfile, appending lines, so you will have logs for all the executions (but be careful with the log size!)</p>

<p><strong>stderr</strong> is captured by cron, who will send an email if there were messages.</p>

<p>In case the django command (and all the stuff behind) is properly programmed you will get only emails when there are errors during the cronjob execution (e.g. lack of disk space while writing the CSV file, which will trigger an IOError exception).</p>

<h1>Having a collection of cronjobs</h1>

<p>You may want to keep the crontabs in a repo. Or in a <strong>chef recipe</strong>. Or deploy them in a package (if you deploy the rest of your software with packages).</p>

<p>Some other peopler prefer to use Celery Periodic Tasks, which means that the periodic tasks are configured in the software, instead of using the system configuration.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing my django webapp API with nose]]></title>
    <link href="http://pfigue.github.io/blog/2013/03/07/testing-my-webapp-api-with-nose/"/>
    <updated>2013-03-07T21:24:00+01:00</updated>
    <id>http://pfigue.github.io/blog/2013/03/07/testing-my-webapp-api-with-nose</id>
    <content type="html"><![CDATA[<p>I have a django webapp with a view <em>/eggplants/search/</em>. I want to test that view automatically with <strong>nose</strong> as part of a test suite, for example, I will run:</p>

<pre><code>legumes/ $ DJANGO_SETTINGS_MODULE='legumes.settings' nosetests eggplants.tests
</code></pre>

<p>and it will execute tests for the views of the module <em>eggplants</em> in the project <em>legumes</em>. Those tests will ask the API, so it needs a server providing the API.</p>

<p><a href="http://werkzeug.pocoo.org/docs/test/"><strong>Werkzeug</strong> provides some help</a> to achieve this in an easy way. The idea is, instead of starting a webserver and make HTTP requests, it will just forward the requests using the WSGI protocol to the webapp. Everything in the same instance, without spawning a webserver. This is ideal for services like Travis.</p>

<p>In <em>legumes/eggplants/test.py</em> I could have something like:</p>

<pre><code>from werkzeug.test import Client
from werkzeug.wrappers import BaseResponse
from legumes.wsgi import application as app

def test_eggplants_search():
    c = Client(app, BaseResponse)
    resp = c.get('/eggplants/search/?color=red')
    assert( resp.status_code==200 and len(resp.data)&gt;0 )
</code></pre>

<p>This will do a GET request to <em>/eggplants/search/?color=red</em> and check for the answer length and code.</p>

<p><em>legumes/legumes/wsgi.py</em>  is <a href="https://docs.djangoproject.com/en/dev/howto/deployment/wsgi/">created when you run the <em>startproject</em> command</a> in Django.</p>

<p>References:</p>

<ul>
<li><a href="http://werkzeug.pocoo.org/docs/test/">Werkzeug: Test Utilities</a></li>
<li><a href="https://docs.djangoproject.com/en/dev/howto/deployment/wsgi/">How to deploy with WSGI</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
